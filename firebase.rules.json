{
  "rules": {
    // PRODUCTION-READY SECURITY RULES
    // Privacy-first design: users can only access content they're authorized to see
    // NOTE: Multi-path updates are validated by each individual path's rules
    
    // Users: Privacy-respecting profile access
    "users": {
      ".indexOn": ["privacy"],
      "$uid": {
        // Allow users to read their own profile completely
        ".read": "auth != null && auth.uid === $uid",
        ".write": "auth != null && auth.uid === $uid",
        ".validate": "newData.hasChildren(['username', 'createdAt'])",
        
        // Basic profile info - readable by all authenticated users (for search/discovery)
        "username": {
          ".read": "auth != null",
          ".validate": "newData.isString() && newData.val().length >= 3 && newData.val().length <= 20"
        },
        "displayName": {
          ".read": "auth != null",
          ".validate": "newData.isString() && newData.val().length >= 1 && newData.val().length <= 50"
        },
        "photoURL": {
          ".read": "auth != null"
        },
        "privacy": {
          ".read": "auth != null",
          ".write": "auth != null && auth.uid === $uid",
          ".validate": "newData.val() === 'public' || newData.val() === 'private'"
        },
        "followersCount": {
          ".read": "auth != null"
        },
        "followingCount": {
          ".read": "auth != null"
        },
        
        // Extended profile - only if owner, following/follower relationship, or public account
        "bio": {
          ".read": "auth != null && (auth.uid === $uid || root.child('following').child(auth.uid).child($uid).exists() || root.child('followers').child(auth.uid).child($uid).exists() || root.child('users').child($uid).child('privacy').val() === 'public')",
          ".validate": "newData.isString() && newData.val().length <= 160"
        },
        "createdAt": {
          ".read": "auth != null && (auth.uid === $uid || root.child('following').child(auth.uid).child($uid).exists() || root.child('followers').child(auth.uid).child($uid).exists() || root.child('users').child($uid).child('privacy').val() === 'public')"
        },
        
        // Sensitive fields - only owner can read
        "email": {
          ".read": "auth != null && auth.uid === $uid"
        },
        "phone": {
          ".read": "auth != null && auth.uid === $uid"
        },
        "inviteCodes": {
          ".read": "auth != null && auth.uid === $uid",
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Usernames: readable by EVERYONE (needed for signup availability check and search)
    "usernames": {
      ".read": true,
      "$username": {
        ".write": "auth != null && (!data.exists() || data.val() === auth.uid)",
        ".validate": "newData.isString()"
      }
    },
    
    // Yaps: Privacy-respecting content access
    "yaps": {
      "$yapId": {
        // Can read if: you're the owner, you follow them, they follow you, they have a public account,
        // OR this is a reply and you can read the parent yap (allows threaded conversation access)
        ".read": "auth != null && (data.child('uid').val() === auth.uid || root.child('following').child(auth.uid).child(data.child('uid').val()).exists() || root.child('followers').child(auth.uid).child(data.child('uid').val()).exists() || root.child('users').child(data.child('uid').val()).child('privacy').val() === 'public' || (data.child('replyTo').exists() && (root.child('yaps').child(data.child('replyTo').val()).child('uid').val() === auth.uid || root.child('following').child(auth.uid).child(root.child('yaps').child(data.child('replyTo').val()).child('uid').val()).exists() || root.child('followers').child(auth.uid).child(root.child('yaps').child(data.child('replyTo').val()).child('uid').val()).exists() || root.child('users').child(root.child('yaps').child(data.child('replyTo').val()).child('uid').val()).child('privacy').val() === 'public')))",
        ".write": "auth != null && (!data.exists() || data.child('uid').val() === auth.uid)",
        ".validate": "newData.hasChildren(['timestamp', 'uid', 'username']) && (newData.hasChild('text') || newData.hasChild('media'))",
        
        // Text validation (max 280 characters, optional if media exists)
        "text": {
          ".validate": "newData.isString() && newData.val().length <= 280"
        },
        
        // UID must match authenticated user
        "uid": {
          ".validate": "newData.val() === auth.uid"
        },
        
        // Timestamp validation (allow 5 minutes time difference for clock skew)
        "timestamp": {
          ".validate": "newData.isNumber() && newData.val() <= (now + 300000) && newData.val() >= (now - 86400000)"
        }
      }
    },
    
    // User Yaps: Same privacy rules as yaps
    "userYaps": {
      "$uid": {
        ".indexOn": ["timestamp"],
        // Can read if: you're the owner, you follow them, they follow you, OR they have a public account
        ".read": "auth != null && (auth.uid === $uid || root.child('following').child(auth.uid).child($uid).exists() || root.child('followers').child(auth.uid).child($uid).exists() || root.child('users').child($uid).child('privacy').val() === 'public')",
        "$yapId": {
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Likes: Only visible if the yap is visible to you
    "likes": {
      "$yapId": {
        // Can read likes if you can read the yap
        ".read": "auth != null && (root.child('yaps').child($yapId).child('uid').val() === auth.uid || root.child('following').child(auth.uid).child(root.child('yaps').child($yapId).child('uid').val()).exists() || root.child('followers').child(auth.uid).child(root.child('yaps').child($yapId).child('uid').val()).exists() || root.child('users').child(root.child('yaps').child($yapId).child('uid').val()).child('privacy').val() === 'public')",
        "$uid": {
          ".write": "auth != null && (auth.uid === $uid || root.child('yaps').child($yapId).child('uid').val() === auth.uid)"
        }
      }
    },
    
    // User Likes: Only owner can see their likes
    "userLikes": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$yapId": {
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Reyaps: Only visible if the yap is visible to you
    "reyaps": {
      "$yapId": {
        ".read": "auth != null && (root.child('yaps').child($yapId).child('uid').val() === auth.uid || root.child('following').child(auth.uid).child(root.child('yaps').child($yapId).child('uid').val()).exists() || root.child('followers').child(auth.uid).child(root.child('yaps').child($yapId).child('uid').val()).exists() || root.child('users').child(root.child('yaps').child($yapId).child('uid').val()).child('privacy').val() === 'public')",
        "$uid": {
          ".write": "auth != null && (auth.uid === $uid || root.child('yaps').child($yapId).child('uid').val() === auth.uid)"
        }
      }
    },
    
    // User Reyaps: Only owner can see their reyaps
    "userReyaps": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$yapId": {
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Following: Owner can see full list, others can check specific relationships
    "following": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$targetUid": {
          // Allow reading if checking if this user follows YOU (for mutual follow/DM checks)
          ".read": "auth != null && (auth.uid === $uid || $targetUid === auth.uid)",
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Followers: Owner can see full list, others can check specific relationships
    "followers": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$followerUid": {
          // Allow reading if checking if YOU follow this user (for mutual follow/DM checks)
          ".read": "auth != null && (auth.uid === $uid || $followerUid === auth.uid)",
          ".write": "auth != null && auth.uid === $followerUid"
        }
      }
    },
    
    // Notifications: Only owner can read their notifications
    "notifications": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$notificationId": {
          ".write": "auth != null"
        }
      }
    },
    
    // Hashtags: Public for discovery, but rate-limited by validation
    "hashtags": {
      "$tag": {
        ".read": "auth != null",
        "$yapId": {
          ".write": "auth != null",
          ".validate": "newData.isNumber()"
        }
      }
    },
    
    // Trending: Public for discovery
    "trending": {
      "$tag": {
        ".read": "auth != null",
        "count": {
          ".write": "auth != null",
          ".validate": "newData.isNumber()"
        }
      }
    },
    
    // User Bookmarks: Only owner can access
    "userBookmarks": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        ".write": "auth != null && auth.uid === $uid"
      }
    },
    
    // Invite Codes (Legacy - kept for backward compatibility)
    "inviteCodes": {
      ".indexOn": ["createdBy", "used"],
      "$code": {
        ".read": true,
        ".write": "auth != null",
        ".validate": "newData.hasChildren(['createdBy', 'createdAt'])",
        
        // Code validation (8 characters)
        "code": {
          ".validate": "newData.isString() && newData.val().length === 8"
        },
        
        // Used flag validation
        "used": {
          ".validate": "newData.isBoolean()"
        }
      }
    },
    
    // Invites: New email-based invite system
    "invites": {
      ".indexOn": ["createdBy", "email", "used"],
      "$token": {
        // Public read for validation during signup
        ".read": true,
        ".write": "auth != null",
        ".validate": "newData.hasChildren(['token', 'email', 'createdBy', 'createdAt'])",
        
        // Token validation (32 character hex string)
        "token": {
          ".validate": "newData.isString() && newData.val().length === 32"
        },
        
        // Email validation
        "email": {
          ".validate": "newData.isString() && newData.val().matches(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/)"
        },
        
        // Creator validation
        "createdBy": {
          ".validate": "newData.isString()"
        },
        
        // Used flag validation
        "used": {
          ".validate": "newData.isBoolean()"
        },
        
        // Timestamp validation
        "createdAt": {
          ".validate": "newData.isNumber()"
        },
        
        // Invite URL (optional)
        "inviteUrl": {
          ".validate": "newData.isString()"
        },
        
        // Who used it (optional)
        "usedBy": {
          ".validate": "!newData.exists() || newData.isString()"
        },
        
        // When used (optional)
        "usedAt": {
          ".validate": "!newData.exists() || newData.isNumber()"
        },
        
        // Inviter name (optional)
        "inviterName": {
          ".validate": "!newData.exists() || newData.isString()"
        }
      }
    },
    
    // Follow Requests: Only recipient can see their pending requests
    "followRequests": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$requesterId": {
          ".write": "auth != null && (auth.uid === $requesterId || auth.uid === $uid)",
          ".validate": "newData.hasChildren(['timestamp'])"
        }
      }
    },
    
    // Conversations: Only participants can access
    "conversations": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$conversationId": {
          ".write": "auth != null && auth.uid === $uid",
          ".validate": "newData.hasChildren(['otherUserId', 'lastMessage', 'lastMessageTime'])"
        }
      }
    },
    
    // Messages: Only participants in the conversation can read/write
    "messages": {
      "$conversationId": {
        ".read": "auth != null && ($conversationId.contains(auth.uid))",
        "$messageId": {
          ".write": "auth != null && ($conversationId.contains(auth.uid))",
          ".validate": "newData.hasChildren(['senderId', 'receiverId', 'timestamp']) && (newData.hasChild('text') || newData.hasChild('media'))",
          
          "text": {
            ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length <= 1000"
          },
          
          "media": {
            ".validate": "newData.isString() || (newData.hasChildren() && newData.val() !== null)"
          }
        }
      }
    },
    
    // Yap Replies: Tracks which yaps are replies to others
    "yapReplies": {
      "$yapId": {
        ".read": "auth != null",
        "$replyId": {
          ".write": "auth != null"
        }
      }
    },
    
    // Groups: Public and private topic-based groups
    "groups": {
      ".read": "auth != null",
      "$groupId": {
        // Anyone authenticated can read to discover groups
        ".read": "auth != null",
        // Only authenticated users can create, only creator/admins can update
        ".write": "auth != null && (!data.exists() || data.child('createdBy').val() === auth.uid || root.child('groupMembers').child($groupId).child(auth.uid).child('role').val() === 'admin')",
        ".validate": "newData.hasChildren(['name', 'description', 'topic', 'isPublic', 'createdBy', 'createdAt'])",
        
        "name": {
          ".validate": "newData.isString() && newData.val().length >= 3 && newData.val().length <= 50"
        },
        "description": {
          ".validate": "newData.isString() && newData.val().length >= 10 && newData.val().length <= 500"
        },
        "topic": {
          ".validate": "newData.isString() && newData.val().length >= 3 && newData.val().length <= 50"
        },
        "imageURL": {
          ".validate": "newData.isString()"
        },
        "isPublic": {
          ".validate": "newData.isBoolean()"
        },
        "createdBy": {
          ".validate": "newData.val() === auth.uid"
        },
        "createdAt": {
          ".validate": "newData.isNumber()"
        },
        "memberCount": {
          ".validate": "newData.isNumber() && newData.val() >= 0"
        }
      }
    },
    
    // Group Members: Maps groups to their members
    "groupMembers": {
      "$groupId": {
        ".read": "auth != null && (root.child('groups').child($groupId).child('isPublic').val() === true || root.child('groupMembers').child($groupId).child(auth.uid).exists())",
        "$uid": {
          // Users can join public groups freely, need approval for private
          ".write": "auth != null && (auth.uid === $uid || root.child('groupMembers').child($groupId).child(auth.uid).child('role').val() === 'admin')",
          ".validate": "newData.hasChildren(['joinedAt', 'role'])",
          
          "joinedAt": {
            ".validate": "newData.isNumber()"
          },
          "role": {
            ".validate": "newData.val() === 'member' || newData.val() === 'admin'"
          }
        }
      }
    },
    
    // User Groups: Reverse index for user's group memberships
    "userGroups": {
      "$uid": {
        ".read": "auth != null && auth.uid === $uid",
        "$groupId": {
          ".write": "auth != null && auth.uid === $uid"
        }
      }
    },
    
    // Group Yaps: Yaps posted within a group
    "groupYaps": {
      "$groupId": {
        ".read": "auth != null && (root.child('groups').child($groupId).child('isPublic').val() === true || root.child('groupMembers').child($groupId).child(auth.uid).exists())",
        "$yapId": {
          ".write": "auth != null && root.child('groupMembers').child($groupId).child(auth.uid).exists()"
        }
      }
    },
    
    // Group Join Requests: Requests to join private groups
    "groupJoinRequests": {
      "$groupId": {
        ".read": "auth != null && (root.child('groupMembers').child($groupId).child(auth.uid).child('role').val() === 'admin')",
        "$uid": {
          ".write": "auth != null && (auth.uid === $uid || root.child('groupMembers').child($groupId).child(auth.uid).child('role').val() === 'admin')",
          ".validate": "newData.hasChildren(['requestedAt', 'username', 'displayName'])"
        }
      }
    }
  }
}
